let amf = require('amf-client-js')

let parse = (from, url, callback) => {
    filePath = url;
    let model = { model: null, error: null };

    amf.AMF.init()
        .then(() => {
            let parser;
            if (from === "raml") {
                parser = amf.Core.parser("RAML 1.0", "application/yaml");
            } else if (from === "oas") {
                parser = amf.Core.parser("OAS 2.0", "application/json");
            } else {
                parser = amf.Core.parser("AMF Graph", "application/ld+json");
            }
            parser.parseFileAsync(url).then((amfModel) => {

                let resolvedModel;
                // this has all the types, securitySchemes, traits, resourceTypes, annotations, etc
                let declares = amfModel.declares;
                model.shapes = mapDeclaredShapes(declares);

                if (from === "raml") {
                   resolvedModel = amf.AMF.resolveRaml10(amfModel);
                   // amf.AMF.resolveRaml08
                } else if (from === "oas") {
                   resolvedModel = amf.AMF.resolveOas20(amfModel);
                } else {
                   resolvedModel = amf.AMF.resolveAmfGraph(amfModel);
                }
                model.model = mapModel(resolvedModel);
                
                return callback(model);
            }).catch((ex) => {
                model.error = ex;
                return callback(model);
            });
        })
        .catch((ex) => {
            throw ex
        });
}

let mapDeclaredShapes = (declares) => {
    if(declares === null)
        return [];
    
    return declares.map(function(decl){
        if('inherits' in decl){ // is a shape
            return mapShape(decl);
        }
    });
}

let mapModel = (amfModel) => {
    let encodes = amfModel.encodes;
    if(encodes == null)
        return null;
    
    let mappedModel = {
        raw: amfModel.raw,
        name: encodes.name,
        description: encodes.description,
        host: encodes.host,
        schemes: encodes.schemes,
        endpoints: mapEndpoints(encodes.endPoints),
        basePath: encodes.basePath,
        accepts: encodes.accepts,
        contentType: encodes.contentType,
        version: encodes.version,
        termsOfService: encodes.termsOfService,
        provider: mapOrganization(encodes.provider),
        license: mapLicense(encodes.license),
        documentations: mapDocumentations(encodes.documentations),
        baseUriParameters: mapParameters(encodes.baseUriParameters),
        security: mapSecurities(encodes.security)
    }
    return mappedModel;
}

let mapOrganization = (organization) => {
    if(!organization)
        return null;

    return {
        url: organization.url,
        name: organization.name,
        email: organization.email
    }
}

let mapLicense = (license) => {
    if(!license)
        return null;

    return {
        url: license.url,
        name: license.name
    }
}

let mapEndpoints = (endpoints) => {
    if(!endpoints)
        return [];
    
    return endpoints.map(function(endpoint) {
        return {
            name: endpoint.name,
            path: endpoint.path,
            description: endpoint.description,
            operations: mapOperations(endpoint.operations),
            parameters: mapParameters(endpoint.parameters),
            security: mapSecuritySchemes(endpoint.security)
        };
    });
}

let mapOperations = (operations) => {
    if(!operations)
        return [];

    return operations.map(function(op){
        return {
            method: op.method,
            name: op.name,
            description: op.description,
            deprecated: op.deprecated,
            summary: op.summary,
            documentation: mapDocumentation(op.documentation),
            schemes: op.schemes,
            accepts: op.accepts,
            contentType: op.contentType,
            request: mapRequest(op.request),
            responses: mapResponses(op.responses),
            security: mapSecuritySchemes(op.security)
        };
    });
}

let mapDocumentations = (documentations) => {
    if(!documentations)
        return [];
    
    return documentations.map(mapDocumentation);
}

let mapDocumentation = (documentation) => {
    if(!documentation)
        return null;

    return {
        url: documentation.url,
        description: documentation.description,
        title: documentation.title
    };
}

let mapRequest = (request) => {
    if(!request)
        return null;
    
    return {
        queryParameters: mapParameters(request.queryParameters),
        headers: mapParameters(request.headers),
        payloads: mapPayloads(request.payloads),
        queryString: mapShape(request.queryString)
    }
}

let mapResponses = (responses) => {
    if(!responses)
        return [];
    
    return responses.map(function(response){
        return {
            name: response.name,
            description: response.description,
            statusCode: response.statusCode,
            headers: mapParameters(response.headers),
            payloads: mapPayloads(response.payloads),
            examples: mapExamples(response.examples)
        }
    });
}

let mapSecurities = (securities) => {
    if(!securities)
        return [];
    
    return securities.map(mapSecurity);
}

let mapSecurity = (security) => {
    if(!security)
        return [];
    
    return security.map(function(sec){
        return {
            name: sec.name,
            scheme: mapSecurityScheme(sec.scheme),
            settings: mapSettings(sec.settings)
        }
    });
}

let mapSecuritySchemes = (securitySchemes) => {
    if(!securitySchemes)
        return [];
    
    return securitySchemes.map(mapSecurityScheme);
}

let mapSecurityScheme = (scheme) => {
    if(!scheme)
        return null;
    
    return {
        name: scheme.name,
        type: scheme.type,
        displayName: scheme.displayName,
        description: scheme.description,
        headers: mapParameters(scheme.headers),
        queryParameters: mapParameters(scheme.queryParameters),
        responses: mapResponses(scheme.responses),
        settings: mapSettings(scheme.settings, scheme.type),
        queryString: mapShape(scheme.queryString)
    };
}

let mapSettings = (settings, type) => {
    if(!settings)
        return null;

    if(type === 'OAuth 1.0'){
        return {
            requestTokenUri: settings.requestTokenUri,
            authorizationUri: settings.authorizationUri,
            tokenCredentialsUri: settings.tokenCredentialsUri,
            signatures: settings.signatures
        };
    }

    if(type === 'OAuth 2.0'){
        return {
            authorizationUri: settings.authorizationUri,
            accessTokenUri: settings.accessTokenUri,
            authorizationGrants: settings.authorizationGrants,
            flow: settings.flow,
            scopes: mapScopes(settings.scopes)
        };
    }

    if(type === 'ApiKey'){
        return {
            name: settings.name,
            in: settings.in
        };
    }
    
    return {
        requestTokenUri: settings.requestTokenUri,
        authorizationUri: settings.authorizationUri,
        tokenCredentialsUri: settings.tokenCredentialsUri,
        signatures: settings.signatures,
        accessTokenUri: settings.accessTokenUri,
        authorizationGrants: settings.authorizationGrants,
        flow: settings.flow,
        scopes: mapScopes(settings.scopes),
        name: settings.name,
        in: settings.in
    };
}

let mapScopes = (scopes) => {
    if(!scopes)
        return [];

    return scopes.map(function(scope){
        return {
            name: scope.name,
            description: scope.description
        };
    });
}

let mapParameters = (parameters) => {
    if(!parameters)
        return [];
    
    return parameters.map(function(param){
        return {
            name: param.name,
            description: param.description,
            required: param.required,
            binding: param.binding,
            schema: mapSchema(param.schema)
        }
    });
}

let mapPayloads = (payloads) => {
    if(!payloads)
        return [];
    
    return payloads.map(function(payload){
        return {
            mediaType: payload.mediaType,
            schema: mapSchema(payload.schema)
        }
    });
}

let mapSchema = (schema) => {
    if(!schema)
        return null;

    let result = mapShape(schema);
    result.mediaType = schema.mediaType;
    result.raw = schema.raw;
    return result;
}

let mapShape = (shape) => {
    if(!shape)
        return null;
    
    return {
        // shape
        name: shape.name,
        displayName: shape.displayName,
        description: shape.description,
        default: shape.default,
        values: shape.values,
        inherits: mapShapes(shape.inherits),

        // any
        documentation: mapDocumentation(shape.documentation),
        xmlSerialization: mapXmlSerialization(shape.xmlSerialization),
        examples: mapExamples(shape.examples),

        // union
        anyOf: mapShapes(shape.anyOf),

        // array
        minItems: shape.minItems,
        maxItems: shape.maxItems,
        uniqueItems: shape.uniqueItems,
        items: mapShape(shape.items),
        linkTarget: mapLinkTarget(shape.linkTarget),

        // scalar
        dataType: shape.dataType,
        pattern: shape.pattern,
        minLength: shape.minLength,
        maxLength: shape.maxLength,
        minimum: shape.minimum,
        maximum: shape.maximum,
        exclusiveMinimum: shape.exclusiveMinimum,
        exclusiveMaximum: shape.exclusiveMaximum,
        format: shape.format,
        multipleOf: shape.multipleOf,
        
        // node
        minProperties: shape.minProperties,
        maxProperties: shape.maxProperties,
        closed: shape.closed,
        discriminator: shape.discriminator,
        discriminatorValue: shape.discriminatorValue,
        readOnly: shape.readOnly,
        properties: mapProperties(shape.properties),
        dependencies: mapDependencies(shape.dependencies),
        
        // file
        fileTypes: shape.fileTypes
    }
}

let mapLinkTarget = (linkTarget) => {
    if (linkTarget == null)
        return null;

    return {
        name: linkTarget.value$2 != null ? linkTarget.value$2.name : null
    };
}

let mapProperties = (properties) => {
    if(!properties)
        return [];

    return properties.map(function(prop) {
        return {
            path: prop.path,
            range: mapShape(prop.range),
            minCount: prop.minCount,
            maxCount: prop.maxCount
        };
    });
}

let mapDependencies = (dependencies) => {
    if(!dependencies)
        return [];

    return dependencies.map(function(dep){
        return {
            propertySource: dep.propertySource,
            propertyTarget: dep.propertyTarget
        }
    });
}

let mapShapes = (shapes) => {
    if(!shapes)
        return [];

    // workaround to avoid bug https://www.mulesoft.org/jira/browse/APIMF-606
    var ret = [];
    for(const x of shapes){
        ret.push(mapShape(x));
    }
    return ret;
    //return shapes.map(mapShape);
}

let mapAnyShape = (shape) => {
    if(!shape)
        return null;

    return {
        documentation: mapDocumentation(shape.documentation),
        examples: mapExamples(shape.examples),
        xmlSerialization: mapXmlSerialization(shape.xmlSerialization)
    }
}

let mapExamples = (examples) => {
    if(!examples)
        return [];

    return examples.map(function(example){
        return {
            name: example.name,
            displayName: example.displayName,
            description: example.description,
            value: example.value,
            strict: example.strict,
            mediaType: example.mediaType
        }
    });
}

let mapXmlSerialization = (xmlSerialization) => {
    if(!xmlSerialization)
        return null;
    
    return {
        attribute: xmlSerialization.attribute,
        wrapped: xmlSerialization.wrapped,
        name: xmlSerialization.name,
        namespace: xmlSerialization.namespace,
        prefix: xmlSerialization.prefix
    }
}

exports.parse = parse;